<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>

<title>Introduction</title>

<script type="text/javascript">
window.onload = function() {
  var imgs = document.getElementsByTagName('img'), i, img;
  for (i = 0; i < imgs.length; i++) {
    img = imgs[i];
    // center an image if it is the only element of its parent
    if (img.parentElement.childElementCount === 1)
      img.parentElement.style.textAlign = 'center';
  }
};
</script>

<!-- Styles for R syntax highlighter -->
<style type="text/css">
   pre .operator,
   pre .paren {
     color: rgb(104, 118, 135)
   }

   pre .literal {
     color: #990073
   }

   pre .number {
     color: #099;
   }

   pre .comment {
     color: #998;
     font-style: italic
   }

   pre .keyword {
     color: #900;
     font-weight: bold
   }

   pre .identifier {
     color: rgb(0, 0, 0);
   }

   pre .string {
     color: #d14;
   }
</style>

<!-- R syntax highlighter -->
<script type="text/javascript">
var hljs=new function(){function m(p){return p.replace(/&/gm,"&amp;").replace(/</gm,"&lt;")}function f(r,q,p){return RegExp(q,"m"+(r.cI?"i":"")+(p?"g":""))}function b(r){for(var p=0;p<r.childNodes.length;p++){var q=r.childNodes[p];if(q.nodeName=="CODE"){return q}if(!(q.nodeType==3&&q.nodeValue.match(/\s+/))){break}}}function h(t,s){var p="";for(var r=0;r<t.childNodes.length;r++){if(t.childNodes[r].nodeType==3){var q=t.childNodes[r].nodeValue;if(s){q=q.replace(/\n/g,"")}p+=q}else{if(t.childNodes[r].nodeName=="BR"){p+="\n"}else{p+=h(t.childNodes[r])}}}if(/MSIE [678]/.test(navigator.userAgent)){p=p.replace(/\r/g,"\n")}return p}function a(s){var r=s.className.split(/\s+/);r=r.concat(s.parentNode.className.split(/\s+/));for(var q=0;q<r.length;q++){var p=r[q].replace(/^language-/,"");if(e[p]){return p}}}function c(q){var p=[];(function(s,t){for(var r=0;r<s.childNodes.length;r++){if(s.childNodes[r].nodeType==3){t+=s.childNodes[r].nodeValue.length}else{if(s.childNodes[r].nodeName=="BR"){t+=1}else{if(s.childNodes[r].nodeType==1){p.push({event:"start",offset:t,node:s.childNodes[r]});t=arguments.callee(s.childNodes[r],t);p.push({event:"stop",offset:t,node:s.childNodes[r]})}}}}return t})(q,0);return p}function k(y,w,x){var q=0;var z="";var s=[];function u(){if(y.length&&w.length){if(y[0].offset!=w[0].offset){return(y[0].offset<w[0].offset)?y:w}else{return w[0].event=="start"?y:w}}else{return y.length?y:w}}function t(D){var A="<"+D.nodeName.toLowerCase();for(var B=0;B<D.attributes.length;B++){var C=D.attributes[B];A+=" "+C.nodeName.toLowerCase();if(C.value!==undefined&&C.value!==false&&C.value!==null){A+='="'+m(C.value)+'"'}}return A+">"}while(y.length||w.length){var v=u().splice(0,1)[0];z+=m(x.substr(q,v.offset-q));q=v.offset;if(v.event=="start"){z+=t(v.node);s.push(v.node)}else{if(v.event=="stop"){var p,r=s.length;do{r--;p=s[r];z+=("</"+p.nodeName.toLowerCase()+">")}while(p!=v.node);s.splice(r,1);while(r<s.length){z+=t(s[r]);r++}}}}return z+m(x.substr(q))}function j(){function q(x,y,v){if(x.compiled){return}var u;var s=[];if(x.k){x.lR=f(y,x.l||hljs.IR,true);for(var w in x.k){if(!x.k.hasOwnProperty(w)){continue}if(x.k[w] instanceof Object){u=x.k[w]}else{u=x.k;w="keyword"}for(var r in u){if(!u.hasOwnProperty(r)){continue}x.k[r]=[w,u[r]];s.push(r)}}}if(!v){if(x.bWK){x.b="\\b("+s.join("|")+")\\s"}x.bR=f(y,x.b?x.b:"\\B|\\b");if(!x.e&&!x.eW){x.e="\\B|\\b"}if(x.e){x.eR=f(y,x.e)}}if(x.i){x.iR=f(y,x.i)}if(x.r===undefined){x.r=1}if(!x.c){x.c=[]}x.compiled=true;for(var t=0;t<x.c.length;t++){if(x.c[t]=="self"){x.c[t]=x}q(x.c[t],y,false)}if(x.starts){q(x.starts,y,false)}}for(var p in e){if(!e.hasOwnProperty(p)){continue}q(e[p].dM,e[p],true)}}function d(B,C){if(!j.called){j();j.called=true}function q(r,M){for(var L=0;L<M.c.length;L++){if((M.c[L].bR.exec(r)||[null])[0]==r){return M.c[L]}}}function v(L,r){if(D[L].e&&D[L].eR.test(r)){return 1}if(D[L].eW){var M=v(L-1,r);return M?M+1:0}return 0}function w(r,L){return L.i&&L.iR.test(r)}function K(N,O){var M=[];for(var L=0;L<N.c.length;L++){M.push(N.c[L].b)}var r=D.length-1;do{if(D[r].e){M.push(D[r].e)}r--}while(D[r+1].eW);if(N.i){M.push(N.i)}return f(O,M.join("|"),true)}function p(M,L){var N=D[D.length-1];if(!N.t){N.t=K(N,E)}N.t.lastIndex=L;var r=N.t.exec(M);return r?[M.substr(L,r.index-L),r[0],false]:[M.substr(L),"",true]}function z(N,r){var L=E.cI?r[0].toLowerCase():r[0];var M=N.k[L];if(M&&M instanceof Array){return M}return false}function F(L,P){L=m(L);if(!P.k){return L}var r="";var O=0;P.lR.lastIndex=0;var M=P.lR.exec(L);while(M){r+=L.substr(O,M.index-O);var N=z(P,M);if(N){x+=N[1];r+='<span class="'+N[0]+'">'+M[0]+"</span>"}else{r+=M[0]}O=P.lR.lastIndex;M=P.lR.exec(L)}return r+L.substr(O,L.length-O)}function J(L,M){if(M.sL&&e[M.sL]){var r=d(M.sL,L);x+=r.keyword_count;return r.value}else{return F(L,M)}}function I(M,r){var L=M.cN?'<span class="'+M.cN+'">':"";if(M.rB){y+=L;M.buffer=""}else{if(M.eB){y+=m(r)+L;M.buffer=""}else{y+=L;M.buffer=r}}D.push(M);A+=M.r}function G(N,M,Q){var R=D[D.length-1];if(Q){y+=J(R.buffer+N,R);return false}var P=q(M,R);if(P){y+=J(R.buffer+N,R);I(P,M);return P.rB}var L=v(D.length-1,M);if(L){var O=R.cN?"</span>":"";if(R.rE){y+=J(R.buffer+N,R)+O}else{if(R.eE){y+=J(R.buffer+N,R)+O+m(M)}else{y+=J(R.buffer+N+M,R)+O}}while(L>1){O=D[D.length-2].cN?"</span>":"";y+=O;L--;D.length--}var r=D[D.length-1];D.length--;D[D.length-1].buffer="";if(r.starts){I(r.starts,"")}return R.rE}if(w(M,R)){throw"Illegal"}}var E=e[B];var D=[E.dM];var A=0;var x=0;var y="";try{var s,u=0;E.dM.buffer="";do{s=p(C,u);var t=G(s[0],s[1],s[2]);u+=s[0].length;if(!t){u+=s[1].length}}while(!s[2]);if(D.length>1){throw"Illegal"}return{r:A,keyword_count:x,value:y}}catch(H){if(H=="Illegal"){return{r:0,keyword_count:0,value:m(C)}}else{throw H}}}function g(t){var p={keyword_count:0,r:0,value:m(t)};var r=p;for(var q in e){if(!e.hasOwnProperty(q)){continue}var s=d(q,t);s.language=q;if(s.keyword_count+s.r>r.keyword_count+r.r){r=s}if(s.keyword_count+s.r>p.keyword_count+p.r){r=p;p=s}}if(r.language){p.second_best=r}return p}function i(r,q,p){if(q){r=r.replace(/^((<[^>]+>|\t)+)/gm,function(t,w,v,u){return w.replace(/\t/g,q)})}if(p){r=r.replace(/\n/g,"<br>")}return r}function n(t,w,r){var x=h(t,r);var v=a(t);var y,s;if(v){y=d(v,x)}else{return}var q=c(t);if(q.length){s=document.createElement("pre");s.innerHTML=y.value;y.value=k(q,c(s),x)}y.value=i(y.value,w,r);var u=t.className;if(!u.match("(\\s|^)(language-)?"+v+"(\\s|$)")){u=u?(u+" "+v):v}if(/MSIE [678]/.test(navigator.userAgent)&&t.tagName=="CODE"&&t.parentNode.tagName=="PRE"){s=t.parentNode;var p=document.createElement("div");p.innerHTML="<pre><code>"+y.value+"</code></pre>";t=p.firstChild.firstChild;p.firstChild.cN=s.cN;s.parentNode.replaceChild(p.firstChild,s)}else{t.innerHTML=y.value}t.className=u;t.result={language:v,kw:y.keyword_count,re:y.r};if(y.second_best){t.second_best={language:y.second_best.language,kw:y.second_best.keyword_count,re:y.second_best.r}}}function o(){if(o.called){return}o.called=true;var r=document.getElementsByTagName("pre");for(var p=0;p<r.length;p++){var q=b(r[p]);if(q){n(q,hljs.tabReplace)}}}function l(){if(window.addEventListener){window.addEventListener("DOMContentLoaded",o,false);window.addEventListener("load",o,false)}else{if(window.attachEvent){window.attachEvent("onload",o)}else{window.onload=o}}}var e={};this.LANGUAGES=e;this.highlight=d;this.highlightAuto=g;this.fixMarkup=i;this.highlightBlock=n;this.initHighlighting=o;this.initHighlightingOnLoad=l;this.IR="[a-zA-Z][a-zA-Z0-9_]*";this.UIR="[a-zA-Z_][a-zA-Z0-9_]*";this.NR="\\b\\d+(\\.\\d+)?";this.CNR="\\b(0[xX][a-fA-F0-9]+|(\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?)";this.BNR="\\b(0b[01]+)";this.RSR="!|!=|!==|%|%=|&|&&|&=|\\*|\\*=|\\+|\\+=|,|\\.|-|-=|/|/=|:|;|<|<<|<<=|<=|=|==|===|>|>=|>>|>>=|>>>|>>>=|\\?|\\[|\\{|\\(|\\^|\\^=|\\||\\|=|\\|\\||~";this.ER="(?![\\s\\S])";this.BE={b:"\\\\.",r:0};this.ASM={cN:"string",b:"'",e:"'",i:"\\n",c:[this.BE],r:0};this.QSM={cN:"string",b:'"',e:'"',i:"\\n",c:[this.BE],r:0};this.CLCM={cN:"comment",b:"//",e:"$"};this.CBLCLM={cN:"comment",b:"/\\*",e:"\\*/"};this.HCM={cN:"comment",b:"#",e:"$"};this.NM={cN:"number",b:this.NR,r:0};this.CNM={cN:"number",b:this.CNR,r:0};this.BNM={cN:"number",b:this.BNR,r:0};this.inherit=function(r,s){var p={};for(var q in r){p[q]=r[q]}if(s){for(var q in s){p[q]=s[q]}}return p}}();hljs.LANGUAGES.cpp=function(){var a={keyword:{"false":1,"int":1,"float":1,"while":1,"private":1,"char":1,"catch":1,"export":1,virtual:1,operator:2,sizeof:2,dynamic_cast:2,typedef:2,const_cast:2,"const":1,struct:1,"for":1,static_cast:2,union:1,namespace:1,unsigned:1,"long":1,"throw":1,"volatile":2,"static":1,"protected":1,bool:1,template:1,mutable:1,"if":1,"public":1,friend:2,"do":1,"return":1,"goto":1,auto:1,"void":2,"enum":1,"else":1,"break":1,"new":1,extern:1,using:1,"true":1,"class":1,asm:1,"case":1,typeid:1,"short":1,reinterpret_cast:2,"default":1,"double":1,register:1,explicit:1,signed:1,typename:1,"try":1,"this":1,"switch":1,"continue":1,wchar_t:1,inline:1,"delete":1,alignof:1,char16_t:1,char32_t:1,constexpr:1,decltype:1,noexcept:1,nullptr:1,static_assert:1,thread_local:1,restrict:1,_Bool:1,complex:1},built_in:{std:1,string:1,cin:1,cout:1,cerr:1,clog:1,stringstream:1,istringstream:1,ostringstream:1,auto_ptr:1,deque:1,list:1,queue:1,stack:1,vector:1,map:1,set:1,bitset:1,multiset:1,multimap:1,unordered_set:1,unordered_map:1,unordered_multiset:1,unordered_multimap:1,array:1,shared_ptr:1}};return{dM:{k:a,i:"</",c:[hljs.CLCM,hljs.CBLCLM,hljs.QSM,{cN:"string",b:"'\\\\?.",e:"'",i:"."},{cN:"number",b:"\\b(\\d+(\\.\\d*)?|\\.\\d+)(u|U|l|L|ul|UL|f|F)"},hljs.CNM,{cN:"preprocessor",b:"#",e:"$"},{cN:"stl_container",b:"\\b(deque|list|queue|stack|vector|map|set|bitset|multiset|multimap|unordered_map|unordered_set|unordered_multiset|unordered_multimap|array)\\s*<",e:">",k:a,r:10,c:["self"]}]}}}();hljs.LANGUAGES.r={dM:{c:[hljs.HCM,{cN:"number",b:"\\b0[xX][0-9a-fA-F]+[Li]?\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\b\\d+(?:[eE][+\\-]?\\d*)?L\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\b\\d+\\.(?!\\d)(?:i\\b)?",e:hljs.IMMEDIATE_RE,r:1},{cN:"number",b:"\\b\\d+(?:\\.\\d*)?(?:[eE][+\\-]?\\d*)?i?\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\.\\d+(?:[eE][+\\-]?\\d*)?i?\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"keyword",b:"(?:tryCatch|library|setGeneric|setGroupGeneric)\\b",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\.\\.\\.",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\.\\.\\d+(?![\\w.])",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\b(?:function)",e:hljs.IMMEDIATE_RE,r:2},{cN:"keyword",b:"(?:if|in|break|next|repeat|else|for|return|switch|while|try|stop|warning|require|attach|detach|source|setMethod|setClass)\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"literal",b:"(?:NA|NA_integer_|NA_real_|NA_character_|NA_complex_)\\b",e:hljs.IMMEDIATE_RE,r:10},{cN:"literal",b:"(?:NULL|TRUE|FALSE|T|F|Inf|NaN)\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"identifier",b:"[a-zA-Z.][a-zA-Z0-9._]*\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"operator",b:"<\\-(?!\\s*\\d)",e:hljs.IMMEDIATE_RE,r:2},{cN:"operator",b:"\\->|<\\-",e:hljs.IMMEDIATE_RE,r:1},{cN:"operator",b:"%%|~",e:hljs.IMMEDIATE_RE},{cN:"operator",b:">=|<=|==|!=|\\|\\||&&|=|\\+|\\-|\\*|/|\\^|>|<|!|&|\\||\\$|:",e:hljs.IMMEDIATE_RE,r:0},{cN:"operator",b:"%",e:"%",i:"\\n",r:1},{cN:"identifier",b:"`",e:"`",r:0},{cN:"string",b:'"',e:'"',c:[hljs.BE],r:0},{cN:"string",b:"'",e:"'",c:[hljs.BE],r:0},{cN:"paren",b:"[[({\\])}]",e:hljs.IMMEDIATE_RE,r:0}]}};
hljs.initHighlightingOnLoad();
</script>

<!-- MathJax scripts -->
<script type="text/javascript" src="https://cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML">
</script>


<style type="text/css">
body, td {
   font-family: sans-serif;
   background-color: white;
   font-size: 13px;
}

body {
  max-width: 800px;
  margin: auto;
  padding: 1em;
  line-height: 20px;
}

tt, code, pre {
   font-family: 'DejaVu Sans Mono', 'Droid Sans Mono', 'Lucida Console', Consolas, Monaco, monospace;
}

h1 {
   font-size:2.2em;
}

h2 {
   font-size:1.8em;
}

h3 {
   font-size:1.4em;
}

h4 {
   font-size:1.0em;
}

h5 {
   font-size:0.9em;
}

h6 {
   font-size:0.8em;
}

a:visited {
   color: rgb(50%, 0%, 50%);
}

pre, img {
  max-width: 100%;
}
pre {
  overflow-x: auto;
}
pre code {
   display: block; padding: 0.5em;
}

code {
  font-size: 92%;
  border: 1px solid #ccc;
}

code[class] {
  background-color: #F8F8F8;
}

table, td, th {
  border: none;
}

blockquote {
   color:#666666;
   margin:0;
   padding-left: 1em;
   border-left: 0.5em #EEE solid;
}

hr {
   height: 0px;
   border-bottom: none;
   border-top-width: thin;
   border-top-style: dotted;
   border-top-color: #999999;
}

@media print {
   * {
      background: transparent !important;
      color: black !important;
      filter:none !important;
      -ms-filter: none !important;
   }

   body {
      font-size:12pt;
      max-width:100%;
   }

   a, a:visited {
      text-decoration: underline;
   }

   hr {
      visibility: hidden;
      page-break-before: always;
   }

   pre, blockquote {
      padding-right: 1em;
      page-break-inside: avoid;
   }

   tr, img {
      page-break-inside: avoid;
   }

   img {
      max-width: 100% !important;
   }

   @page :left {
      margin: 15mm 20mm 15mm 10mm;
   }

   @page :right {
      margin: 15mm 10mm 15mm 20mm;
   }

   p, h2, h3 {
      orphans: 3; widows: 3;
   }

   h2, h3 {
      page-break-after: avoid;
   }
}
</style>



</head>

<body>
<!--
%\VignetteEngine{knitr::rmarkdown}  
%\VignetteIndexEntry{Matching Algorithms in R and C++: An Introduction to matchingR}
%\usepackage[utf8]{inputenc}
-->

<h1>Introduction</h1>

<p><code>matchingR</code> is an R package which quickly computes the <a href="http://www.jstor.org/stable/2312726">Gale-Shapley algorithm</a> [@gale1962college], <a href="http://www.sciencedirect.com/science/article/pii/0196677485900331">Irving&#39;s algorithm for the stable roommate problem</a> [@irving1985roommates], and the <a href="http://pareto.uab.es/jmasso/pdf/ShapleyScarfJME1974.pdf">top trading cycle algorithm</a> [@shapley1973cores] for large matching markets. The package provides functions to compute the solutions to the
  <a href="http://en.wikipedia.org/wiki/Stable_matching">stable marriage problem</a>, the
  <a href="http://en.wikipedia.org/wiki/Hospital_resident">college admission problem</a>, the
  <a href="http://en.wikipedia.org/wiki/Stable_roommates_problem">stable roommates problem</a>, and the
  <a href="http://web.stanford.edu/%7Eniederle/HouseAllocation.pdf">house allocation problem</a>.</p>

<p>The package may be useful when the number of market participants is large or when many matchings need to be computed (e.g., for simulation or estimation purposes). It has been used in practice to compute the Gale-Shapley stable matching with 30,000 participants on each side of the market.</p>

<p>Matching markets are common in practice and widely studied by economists. Popular examples include</p>

<ul>
<li>the <a href="http://www.nrmp.org/">National Resident Matching Program</a> that matches graduates from medical school to residency programs at teaching hospitals throughout the United States</li>
<li>the matching of students to schools including the <a href="http://www.jstor.org/stable/4132848">New York City High School Match</a> or the the <a href="http://www.jstor.org/stable/4132849">Boston Public School Match</a> (and many more)</li>
<li>the matching of kidney donors to recipients in <a href="http://www.jstor.org/stable/4132851">kidney exchanges</a>.</li>
</ul>

<h1>Two-sided Matching Markets: Gale-Shapley Algorithm</h1>

<p>Consider the following marriage market: There are <code>N</code> men and <code>N</code> women. Each man, <code>m</code>, receives utility <code>uM(w, m)</code> from a match with woman <code>w</code>, and similarly each woman receives a payoff of <code>uW(m, w)</code> from being matched with a man. </p>

<p>A matching assigns men to women such that each man is assigned to one woman and each woman is assigned to one man. A matching is <strong>stable</strong> if there is no man and woman who would jointly prefer to be matched to each other over their current spouses. In other words, a matching is stable if there are no pairs <code>(m, w&#39;), (m&#39;, w)</code>, such that <code>m</code> is matched with <code>w&#39;</code>, <code>m&#39;</code> is matched with <code>w</code>, and both <code>uW(m, w) &gt; uW(m&#39;, w)</code> and <code>uM(m, w) &gt; uM(m, w&#39;)</code>. </p>

<p>For example, we might have preferences for men given by</p>

<pre><code class="r">uM = matrix(c(1.0, 0.5, 0.0,
              0.5, 0.0, 0.5,
              0.0, 1.0, 1.0), nrow = 3, ncol = 3, byrow = TRUE)
</code></pre>

<pre><code>##          cols
## rows      Man 1 Man 2 Man 3
##   Woman 1   1.0   0.5   0.0
##   Woman 2   0.5   0.0   0.5
##   Woman 3   0.0   1.0   1.0
</code></pre>

<p>In this example, man <code>1</code> receives a payoff of <code>1.0</code> from being matched to woman <code>1</code>, a payoff of <code>0.5</code> from being matched to woman <code>2</code> and a payoff of <code>0.0</code> from being matched to woman 3 (same logic applies to men <code>2</code> and <code>3</code>). Similarly, we might have preferences for women given by</p>

<pre><code class="r">uW = matrix(c(0.0, 1.0, 0.0,
              0.5, 0.0, 0.5,
              1.0, 0.5, 1.0), nrow = 3, ncol = 3, byrow = TRUE)
</code></pre>

<pre><code>##        cols
## rows    Woman 1 Woman 2 Woman 3
##   Man 1     0.0     1.0     0.0
##   Man 2     0.5     0.0     0.5
##   Man 3     1.0     0.5     1.0
</code></pre>

<p>Here, columns in the matrix correspond to women, rows to men. In this example, woman <code>1</code> receives a payoff of <code>0.0</code> from being matched to man <code>1</code>, a payoff of <code>0.5</code> from being matched to man <code>2</code> and a payoff of <code>1.0</code> from being matched to man 3 (same logic applies to women <code>2</code> and <code>3</code>).</p>

<p>Instead of using payoff matrices, we can also represent preferences using preference orderings. The preference ordering that corresponds to <code>uM</code> is</p>

<pre><code class="r">prefM = matrix(c(1, 3, 3,
                 2, 1, 2,
                 3, 2, 1), nrow = 3, ncol = 3, byrow = TRUE)
</code></pre>

<pre><code>##         cols
## rows     Man 1 Man 2 Man 3
##   Rank 1     1     3     3
##   Rank 2     2     1     2
##   Rank 3     3     2     1
</code></pre>

<p><code>prefM</code> states that man <code>1</code> prefers woman <code>1</code> over woman <code>2</code> over woman <code>3</code>, etc. The preference ordering that corresponds to <code>uW</code> is given by</p>

<pre><code class="r">prefW = matrix(c(3, 1, 3,
                 2, 3, 2,
                 1, 2, 1), nrow = 3, ncol = 3, byrow = TRUE)
</code></pre>

<pre><code>##         cols
## rows     Woman 1 Woman 2 Woman 3
##   Rank 1       3       1       3
##   Rank 2       2       3       2
##   Rank 3       1       2       1
</code></pre>

<p>The matching algorithm discussed below can take either payoff matrices of the type <code>uM</code> and <code>uW</code> or preference orderings of the type <code>prefM</code> and <code>prefW</code> as arguments.</p>

<p>The Gale-Shapley algorithm works as follows: Single men (&ldquo;the proposers&rdquo;) sequentially make proposals to each of their most preferred available women (&ldquo;the reviewers&rdquo;). A woman can hold on to at most one proposal at a time. A <em>single</em> woman will accept any proposal that is made to her. A woman who already has a proposal will reject any proposal she values less than her current proposal in hand. If a woman receives a proposal from a man that she values more than her current proposal, she will accept the proposal and her previous match will rejoin the line of proposers. This process continues until all men are matched to all women. </p>

<p>For the preferences specified in <code>uM</code> and <code>uW</code>, we can compute the Gale-Shapley Algorithm by hand. Initially, all men are single.</p>

<ol>
<li>* Man <code>1</code> proposes to woman <code>1</code>, his most-preferred choice.

<ul>
<li>Unmatched men: <code>2</code>, <code>3</code></li>
</ul></li>
<li>* Man <code>2</code> proposes to woman <code>3</code>, his most-preferred choice.

<ul>
<li>Unmatched men: <code>3</code></li>
</ul></li>
<li>* Man <code>3</code> proposes to woman <code>3</code>, his most-preferred choice.

<ul>
<li>Woman <code>3</code> now dumps man <code>2</code>.</li>
<li>Unmatched men: <code>2</code></li>
</ul></li>
<li>* Man <code>2</code> proposes to woman <code>1</code>, his most-preferred available choice.

<ul>
<li>Woman <code>1</code> now dumps man <code>1</code>.</li>
<li>Unmatched men: <code>1</code></li>
</ul></li>
<li><ul>
<li>Man <code>1</code> proposes to woman <code>2</code>, his most-preferred available choice.</li>
</ul>

<ul>
<li>All men are now matched.</li>
</ul>

<p>The man-optimal stable matching is therefore:</p>

<table><thead>
<tr>
<th>Man</th>
<th>Woman</th>
</tr>
</thead><tbody>
<tr>
<td>1</td>
<td>2</td>
</tr>
<tr>
<td>2</td>
<td>1</td>
</tr>
<tr>
<td>3</td>
<td>3</td>
</tr>
</tbody></table></li>
</ol>

<p>The package computes the Gale-Shapley algorithm using the function <code>galeShapley.marriageMarket</code>:</p>

<pre><code class="r">matching = galeShapley.marriageMarket(uM, uW)
</code></pre>

<p>Note that we can obtain equivalent results when we use <code>prefM</code> and <code>prefW</code> as arguments:</p>

<pre><code class="r">matching = galeShapley.marriageMarket(proposerPref = prefM, reviewerPref = prefW)
</code></pre>

<p>The function <code>galeShapley.marriageMarket</code> returns a list <code>matching</code> that includes the vectors <code>proposals</code> and <code>engagements</code> with the final proposals and engagements, respectively. These two vectors contain the same information (i.e. they tell us who is matched with whom). For the example above, the vector of proposals contains</p>

<pre><code class="r">matching$proposals
</code></pre>

<pre><code>##        cols
## rows    Proposed to Woman
##   Man 1                 2
##   Man 2                 1
##   Man 3                 3
</code></pre>

<p>The first element in the vector tells us that man <code>1</code> is matched with woman <code>2</code>. Man <code>2</code> is matched to woman <code>1</code>, and man <code>3</code> is matched to woman <code>3</code>. The vector of engagement contains</p>

<pre><code class="r">matching$engagements
</code></pre>

<pre><code>##          cols
## rows      Engaged to Man
##   Woman 1              2
##   Woman 2              1
##   Woman 3              3
</code></pre>

<p>The first element in the vector tells us that woman <code>1</code> is matched to man <code>2</code>, woman <code>2</code> will be matched to man <code>1</code>, and woman <code>3</code> will be matched to man <code>3</code>.</p>

<p>We can then check if the computed matching is stable using the function <code>checkStability</code>. To check if a matching is stable, we check for each assignment <code>(m,w)</code> if there is some other woman <code>w&#39;</code> that man <code>m</code> would rather be matched with and who would rather be matched to man <code>m</code>. This function will return <code>true</code> if the matching is stable and <code>false</code> otherwise.</p>

<pre><code class="r">galeShapley.checkStability(uM, uW, matching$proposals, matching$engagements)
</code></pre>

<pre><code>## [1] TRUE
</code></pre>

<p>For the simple 3-by-3 example, we can perform this check by hand:</p>

<ul>
<li>Man <code>1</code> is matched to woman <code>2</code>, his second-most preferred choice. His most preferred choice is woman <code>1</code>. Woman <code>1</code> is matched with man <code>2</code> who she prefers over man <code>1</code>. Thus man <code>1</code> cannot do better than woman <code>2</code>.</li>
<li>Man <code>2</code> is matched to woman <code>1</code>, his second-most preferred choice. His most preferred woman is woman <code>3</code>, who is     matched with man <code>3</code>. Since man <code>3</code> is her most-preferred choice, man <code>2</code> cannot do better than woman <code>1</code>.</li>
<li>Man <code>3</code> is matched to women <code>3</code>, his most preferred choice, so he cannot do better.</li>
</ul>

<p>Thus, this matching is stable.</p>

<p>The following examples illustrate some additional features of this package.</p>

<h3>Example: Marriage Market</h3>

<p>The following is an example of <code>galeShapley.marriageMarket</code> with different numbers of participants on each side of the market. There are 2,500 women and 2,000 men. By construction, 500 men will remain unmatched. We randomly generate payoff matrices <code>uM</code> and <code>uW</code> which are drawn from a uniform distribution (<code>runif</code>). We then compute the male-optimal (i.e. men are proposing) and the female-optimal (i.e. woman are proposing) matching.</p>

<pre><code class="r"># set seed
set.seed(1)
# set number of men
nmen = 2500
# set number of women
nwomen = 2000
# generate preferences
uM = matrix(runif(nmen*nwomen), nrow = nwomen, ncol = nmen)
uW = matrix(runif(nmen*nwomen), nrow = nmen, ncol = nwomen)
# male-optimal matching
resultsM = galeShapley.marriageMarket(uM, uW)
str(resultsM)
</code></pre>

<pre><code>## List of 4
##  $ proposals       : num [1:2500, 1] 927 1644 1965 1851 349 ...
##  $ engagements     : num [1:2000, 1] 386 471 1582 598 1657 ...
##  $ single.proposers: num [1:500] 8 11 17 19 26 30 34 37 49 53 ...
##  $ single.reviewers: num(0)
</code></pre>

<pre><code class="r">galeShapley.checkStability(uM, uW, resultsM$proposals, resultsM$engagements)
</code></pre>

<pre><code>## [1] TRUE
</code></pre>

<pre><code class="r"># female-optimal matching
resultsW = galeShapley.marriageMarket(uW, uM)
str(resultsW)
</code></pre>

<pre><code>## List of 4
##  $ proposals       : num [1:2000, 1] 386 471 1582 598 1657 ...
##  $ engagements     : num [1:2500, 1] 927 1644 1965 1851 349 ...
##  $ single.proposers: num(0) 
##  $ single.reviewers: num [1:500] 8 11 17 19 26 30 34 37 49 53 ...
</code></pre>

<pre><code class="r">galeShapley.checkStability(uW, uM, resultsW$proposals, resultsW$engagements)
</code></pre>

<pre><code>## [1] TRUE
</code></pre>

<h3>Example: College Admissions Problem</h3>

<p>The following is an example of <code>galeShapley.collegeAdmissions</code> where 1000 students get matched to 400 colleges, where each college has two slots. By construction, 200 students will remain unmatched. We draw students&#39; and colleges&#39; preferences, <code>uStudents</code> and <code>uColleges</code>, respectively, by from a uniform distribution. </p>

<pre><code class="r"># set seed
set.seed(1)
# set number of students
nstudents = 1000
# set number of colleges
ncolleges = 400
# generate preferences
uStudents = matrix(runif(ncolleges*nstudents), nrow = ncolleges, ncol = nstudents)
uColleges = matrix(runif(nstudents*ncolleges), nrow = nstudents, ncol = ncolleges)
# student-optimal matching
results = galeShapley.collegeAdmissions(studentUtils =  uStudents, collegeUtils =  uColleges, slots = 2)
str(results)
</code></pre>

<pre><code>## List of 4
##  $ unmatched.students: num [1:200] 3 15 23 29 30 36 44 46 48 49 ...
##  $ unmatched.colleges: int(0) 
##  $ matched.colleges  : num [1:400, 1:2] 728 887 28 372 875 775 456 937 402 774 ...
##  $ matched.students  : int [1:1000, 1] 52 70 NA 210 155 170 238 16 371 391 ...
</code></pre>

<pre><code class="r"># check if matching is stable
galeShapley.checkStability(uStudents, uColleges, results$matched.students, results$matched.colleges)
</code></pre>

<pre><code>## [1] TRUE
</code></pre>

<h1>One-sided Matching Markets: Irving&#39;s Algorithm</h1>

<p>This package implements the algorithm by @irving1985roommates for one-sided matching markets.</p>

<p>Consider the following example: A set of <code>n</code> potential roommates, each with ranked preferences over all the other potential roommates, are to be matched to rooms, two roommates per room. A matching is <strong>stable</strong> if there is no roommate <code>r1</code> that would rather be matched to some other roommate <code>d2</code> than to his current roommate <code>r2</code> and the other roommate <code>d2</code> would rather be matched to <code>r1</code> than to his current roommate <code>d1</code>.</p>

<p>Preferences of potential roommates are summarized by an \(n-1 \times n\) dimensional matrix, e.g., if \(n = 6\), </p>

<pre><code class="r">pref = matrix(c(3, 6, 2, 5, 3, 5,
                4, 5, 4, 2, 1, 1,
                2, 4, 5, 3, 2, 3,
                6, 1, 1, 6, 4, 4,
                5, 3, 6, 1, 6, 2), nrow = 5, ncol = 6, byrow = TRUE)
</code></pre>

<p>Column <code>i</code> represents the preferences of the <code>i</code>th roommate, and row <code>j</code> represents the ranking of the roommate whose index is encoded in that row. For example, in the above preference matrix, roommate <code>1</code> most prefers to be matched with roommate <code>3</code>, followed by <code>4</code>, followed by <code>2</code>.</p>

<p>The function <code>roommate.checkPreferences</code> checks if a given preference order is complete, i.e. if all preferences are fully specified. If the preference order is complete, it will return the proper preference order using <code>C++</code> style indexing (beginning at <code>0</code> instead of at <code>1</code>). If the preference order is incomplete, the function will return an error.</p>

<pre><code class="r">roommate.checkPreferences(pref)
</code></pre>

<pre><code>##      [,1] [,2] [,3] [,4] [,5] [,6]
## [1,]    2    5    1    4    2    4
## [2,]    3    4    3    1    0    0
## [3,]    1    3    4    2    1    2
## [4,]    5    0    0    5    3    3
## [5,]    4    2    5    0    5    1
</code></pre>

<p>The algorithm proceeds in two phases.</p>

<p>In phase 1, potential roommates take turns sequentially proposing to the other roommates. Each roommate who is proposed to can accept or reject the proposal. A roommate accepts if he currently has made no better proposal which was accepted to another roommate. If a roommate has accepted a proposal, and then receives a better proposal, he rejects the old proposal and substitutes in the new proposal. </p>

<p>In the above example,</p>

<ol>
<li>Roommate <code>1</code> begins by proposing to roommate <code>3</code>, his most preferred roommate. <code>3</code>, having no better offers, accepts.</li>
<li><code>2</code> proposes to <code>6</code>, who accepts.</li>
<li><code>3</code> proposes to <code>2</code>, who accepts.</li>
<li><code>4</code> proposes to <code>5</code>, who accepts.</li>
<li><code>5</code> proposes to <code>3</code>, who accepts. <code>3</code> cancels his proposal from <code>1</code>.</li>
<li><code>1</code>, having no proposal, proposes to <code>4</code>, who accepts.</li>
<li><code>6</code> proposes to <code>5</code>, who rejects, having a better proposal from <code>4</code>.</li>
<li><code>6</code> proposes to <code>1</code>, who accepts.</li>
</ol>

<p>In phase 2, we begin by eliminating all potential roommate matches which are worse than the current proposals held. For example, in the above example, <code>3</code> has a proposal from <code>5</code>, and so we eliminate <code>1</code> and <code>6</code> from <code>3</code>&#39;s column, and symmetrically eliminate <code>3</code> from <code>1</code> and <code>6</code>&#39;s column. This results in the following &#39;reduced&#39; preference listing:</p>

<pre><code>   6, 2, 5, 3,  
4, 5, 4, 2,    1
2, 4, 5, 3, 2,  
6, 1,    6, 4, 4
   3,    1,    2
</code></pre>

<p>These preferences form what is called a &#39;stable&#39; table, or, &#39;s-table&#39;. (&#39;Stable&#39; for short.) The defining characteristic of a stable table is that if <code>i</code> is the most preferred roommate on <code>j</code>s list, then <code>j</code> is the least preferred roommate on <code>i</code>s list. For example, <code>1</code> most prefers <code>4</code>, but <code>4</code> least prefers <code>1</code>.</p>

<p>The algorithm proceeds by finding and eliminating &#39;rotations&#39;. A rotation is a sequence of pairs of roommates, such that there is a distinct roommate in the first position of each pair, the second roommate in each pair least prefers the roommate he is paired with, the first roommate in each pair most prefers the roommate he is paired with, and finally, the first roommate in each pair ranks the second roommate in the following pair second (modulo the number of pairs, that is, the first roommate in the last pair ranks the second roommate in the first pair second) Once a rotation has been identified, removing it results in another stable table.</p>

<p>For example, <code>(1, 4), (3, 2)</code> is a rotation in the above table, because <code>1</code> loves <code>4</code>, <code>3</code> loves <code>2</code>, <code>4</code> hates <code>1</code>, <code>2</code> hates <code>3</code>, <code>2</code> is second on <code>1</code>s list, and <code>4</code> is second on <code>3</code>&#39;s list. Eliminating this rotation involves <code>2</code> rejecting <code>3</code>, <code>4</code> rejecting <code>1</code>, and then we remove every successive potential roommate as well to preserve the stable table property, resulting in</p>

<pre><code>   6,    5, 3,  
   5, 4, 2,    1
2, 4, 5, 3, 2,  
6, 1,    6, 4, 4
               2
</code></pre>

<p>A further rotation is <code>(1, 2), (2, 6), (4, 5)</code>. Eliminating it yields</p>

<pre><code>            3,  
   5, 4, 2,    1
   4, 5, 3, 2,  
6,
</code></pre>

<p>A final rotation is <code>(2, 5), (3, 4)</code>. Eliminating it yields</p>

<pre><code>            3,  
         2,    1
   4, 5,
6,

</code></pre>

<p>Therefore, a stable matching is for <code>1</code> and <code>6</code> to match, <code>2</code> and <code>4</code> to match, and <code>3</code> and <code>5</code> to match.</p>

<pre><code class="r">results = roommate(pref = pref)
results
</code></pre>

<pre><code>##      [,1]
## [1,]    6
## [2,]    4
## [3,]    5
## [4,]    2
## [5,]    3
## [6,]    1
</code></pre>

<p>The function <code>roommate.checkStability</code> can be used to check if the resulting matching is stable:</p>

<pre><code class="r">roommate.checkStability(pref = pref, matching = results)
</code></pre>

<pre><code>## [1] TRUE
</code></pre>

<h3>Example: Roommate problem</h3>

<p>The function <code>roommate</code> can also be called using a payoff matrix, <code>u</code>, to specify preferences. In <code>u</code>, the element <code>[i,j]</code> refers to the payoff that agent <code>j</code> gets from being matched to agent <code>i</code>. The main diagonal of this matrix contains no information and will be removed by the algorithm.</p>

<pre><code class="r"># generate preferences
N = 10
u = matrix(runif(N^2),  nrow = N, ncol = N)
results = roommate(utils = u)
results
</code></pre>

<pre><code>##       [,1]
##  [1,]    3
##  [2,]    4
##  [3,]    1
##  [4,]    2
##  [5,]    7
##  [6,]   10
##  [7,]    5
##  [8,]    9
##  [9,]    8
## [10,]    6
</code></pre>

<pre><code class="r">roommate.checkStability(utils = u, matching = results)
</code></pre>

<pre><code>## [1] TRUE
</code></pre>

<h3>Example: Roommate problem when no stable matching exists</h3>

<p>Note that in the roommate problem, existence of a stable matching is not guaranteed. When no stable matching can be found, the function <code>roommate</code> returns <code>NULL</code>.</p>

<pre><code class="r">set.seed(1)
N = 512
u = matrix(runif(N^2),  nrow = N, ncol = N)
results = roommate(utils = u)
print(results)
</code></pre>

<pre><code>## NULL
</code></pre>

<h1>Kidneys and Housing: The Top Trading Cycle Algorithm</h1>

<p>This package implements the top trading cycle algorithm.</p>

<p>Consider the following problem: A set of \(n\) agents each currently own their own home, and have preferences over the homes of other agents. The problem is to trade the homes between the agents in such a way so that no two agents want to swap homes.</p>

<p>Preferences of agents are summarized by an \(n \times n\) dimensional matrix, e.g., if \(n = 4\), </p>

<pre><code class="r">pref = matrix(c(4, 4, 2, 4,
                2, 1, 1, 1,
                1, 2, 3, 3,
                3, 3, 4, 2), nrow = 4, ncol = 4, byrow = TRUE)
</code></pre>

<p>Column \(i\) represents the preferences of the $i$th agent, and row \(j\) represents the ranking of the roommate whose index is encoded in that row. For example, in the above preference matrix, agent <code>1</code> most prefers the home of agent <code>4</code>, followed by <code>2</code>, followed by <code>1</code>, followed by <code>3</code>.</p>

<p>Roughly speaking, the top trading cycle proceeds by identifying cycles of agents, then eliminating those cycles until no agents remain. A cycle is a sequence of agents such that each agent most prefers the next agent&#39;s home (out of the remaining unmatched agents), and the last agent in the sequence most prefers the first agent in the sequence&#39;s home. </p>

<pre><code>4,  4,  2,  4
2,  1,  1,  1
1,  2,  3,  3
3,  3,  4,  2
</code></pre>

<p>For example, for the above preference matrix, when all the agents are unmatched, the only rotation is \(\{4\}\), representing the fact that agent <code>4</code> most prefers his own house. Therefore, the algorithm begins by matching agent <code>4</code> to himself, and then removing him from the pool:</p>

<pre><code>        2
2,  1,  1
1,  2,  3
3,  3,
</code></pre>

<p>Now, a rotation is \(\{1, 2\}\), because <code>1</code> most prefers <code>2</code>s house, and <code>2</code> most prefers <code>1</code>s house. So agents <code>1</code> and <code>2</code> will swap homes, leaving agent <code>3</code> all by himself. </p>

<pre><code>

        3

</code></pre>

<p>Therefore, the final matching is that agent <code>1</code> swaps with agent <code>2</code>, and agents <code>3</code> and <code>4</code> keep their own homes.</p>

<pre><code class="r">results = toptrading(pref = pref)
results
</code></pre>

<pre><code>##      [,1]
## [1,]    2
## [2,]    1
## [3,]    3
## [4,]    4
</code></pre>

<p>The function <code>toptrading.checkStability</code> can be used to check if the resulting allocation is in fact stable: </p>

<pre><code class="r">toptrading.checkStability(pref = pref, matchings = results)
</code></pre>

<pre><code>## [1] TRUE
</code></pre>

<h1>Literature</h1>

</body>

</html>
